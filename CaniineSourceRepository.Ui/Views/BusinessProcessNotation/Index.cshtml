@using CanineSourceRepository.BusinessProcessNotation.Context.Feature
@model UiModel

<div style="display:grid; grid-template-columns: auto 250px;">
  <h1>
    @Model.Feature.Name
  </h1>

  <button onclick="Save()">Save</button>
</div>

<div class="feature-info">
  <p><strong>Version:</strong>@Model.Feature.Version</p>
  <p><strong>Timestamp:</strong>@Model.Feature.Timestamp</p>
  <p><strong>User:</strong>@Model.Feature.User</p>
  <p>
    <strong>Environments:</strong>
    <ul>
    @foreach (var env in Model.Feature.TargetEnvironments)
    {
      <li>
          @env.ToString()
      </li>
    }
    </ul>
  </p>
</div>

<div id="bpnCanvas"></div>
<svg id="connectorLayer">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7"
            refX="10" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="black" />
    </marker>
  </defs>
</svg>

@await Html.PartialAsync("Editor")

<script>
  const model = @Html.Raw(JsonSerializer.Serialize(Model, BpnFeatureRepository.bpnJsonSerialize));
  const nodesData = model.Feature.Tasks;
  const nodesPositions = model.Diagram.BpnPositions;
  const connectionsData = model.Feature.Transitions;
  const eventLog = @Html.Raw(JsonSerializer.Serialize(Model.LastRun?.EventLog, BpnFeatureRepository.bpnJsonSerialize));  
  console.log(eventLog)

  function getNodeStatus(nodeId) {
      let result = {
          nodeId: nodeId,
          status: 'Not found',
          ExecutionTimeMs: null
      };

    console.log("looking for: " + nodeId);
      // Loop through eventLog to find NodeSucceeded or NodeFailed for the given NodeId
      for (let event of eventLog) {
          console.log(event);

          if (event.Type === "TaskSucceeded" &&
              event.TaskId === nodeId) {
              result.status = 'Succeeded';
              result.ExecutionTimeMs = event.ExecutionTimeMs;
              break;
          }

          if (event.Type === "TaskFailed" &&
              event.TaskId === nodeId) {
              result.status = 'Failed';
              result.ExecutionTimeMs = event.ExecutionTimeMs;
              break;
          }
      }

      return result;
  }



  function updateConnections() {
    clearConnectedNodes();
    connectionsData.forEach(connection => {
        const node1 = document.getElementById(connection.FromBPN);
        const node2 = document.getElementById(connection.ToBPN);

        if (node1 && node2) {
            connectNodes(node1, node2, "condition for connection");
        }
    });
  }
  function renderModel() {
    nodesData.forEach(node => {
      var definition = nodesPositions.find(x => x.Id === node.Id);
      var status = getNodeStatus(node.Id);
      CreateNode(
        node.Id,
        node.Name,
        node.Description,
        status.status,
        status.ExecutionTimeMs,
        definition.Position.X,
        definition.Position.Y,
        (id) => { InitializeEditor(node); },//onClick
        (id, x, y) => {
          const nodePosition = nodesPositions.find(n => n.Id === id);
          if (nodePosition) {
            nodePosition.Position.X = x;
            nodePosition.Position.Y = y;
          }
          updateConnections();
        }//onDragged
      );
    });
    updateConnections();
  }

  function Save() {
    model.Feature.Nodes = nodesData;
    model.Diagram.BpnPositions = nodesPositions;

    fetch('/BusinessProcessNotation/Save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(model)
    })
      .then(response => response.text())
      .then(html => {
        document.querySelector('#content').innerHTML = html;
        renderModel();
      })
      .catch((error) => {
        console.error("Error saving data", error);
      });
  }

  renderModel();//fist time render
</script>
